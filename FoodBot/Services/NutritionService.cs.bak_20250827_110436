using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;

namespace FoodBot.Services;

public class NutritionService
{
    private readonly HttpClient _http;
    private readonly string _apiKey;
    private readonly string _visionModel;        // Шаг 1 (визуалка)
    private readonly string _reasoningModel;     // Шаг 2 (финал считает ИИ)
    private readonly bool _debugLog;
    private readonly FoodMatcher _matcher;

    // История и кэш на тред (в памяти)
    private readonly ConcurrentDictionary<Guid, List<object>> _threads = new();
    private readonly ConcurrentDictionary<Guid, MatchedFoodRow[]> _threadFoods = new();
    private readonly ConcurrentDictionary<Guid, string[]> _threadIngredients = new();
    private readonly ConcurrentDictionary<Guid, string> _threadImageDataUrl = new();
    private readonly ConcurrentDictionary<Guid, Step1Snapshot> _threadStep1 = new();

    public NutritionService(IConfiguration cfg, IHttpClientFactory f, IWebHostEnvironment env)
    {
        _http = f.CreateClient();
        _http.Timeout = TimeSpan.FromSeconds(int.TryParse(cfg["OpenAI:TimeoutSeconds"], out var t) ? t : 60);
        _apiKey = cfg["OpenAI:ApiKey"] ?? throw new InvalidOperationException("OpenAI:ApiKey missing");
        _visionModel = cfg["OpenAI:Model"] ?? "gpt-4o-mini";
        _reasoningModel = cfg["OpenAI:ReasoningModel"] ?? "o4-mini";
        _debugLog = bool.TryParse(cfg["OpenAI:DebugLog"], out var dbg) && dbg;

        var foodsPath = cfg["Foods:Path"];
        if (string.IsNullOrWhiteSpace(foodsPath))
            foodsPath = System.IO.Path.Combine(env.ContentRootPath, "foods.json");

        var db = new FoodDb(foodsPath);
        _matcher = new FoodMatcher(db);
    }

    // === Public API ===

    // Обычный путь — анализ фото без уточнения
    public async Task<NutritionConversation?> AnalyzeAsync(byte[] imageBytes, CancellationToken ct)
    {
        var dataUrl = "data:image/jpeg;base64," + Convert.ToBase64String(imageBytes);
        return await AnalyzeCore(dataUrl, userNote: null, ct);
    }

    // Fallback для уточнений без активного треда: анализ той же фотки + текст уточнения
    public async Task<NutritionConversation?> AnalyzeWithNoteAsync(byte[] imageBytes, string userNote, CancellationToken ct)
    {
        var dataUrl = "data:image/jpeg;base64," + Convert.ToBase64String(imageBytes);
        return await AnalyzeCore(dataUrl, userNote, ct);
    }

    // Классический «уточнение по треду» (если память процесса жива)
    public async Task<NutritionConversation?> ClarifyAsync(Guid threadId, string userNote, CancellationToken ct)
    {
        if (!_threads.TryGetValue(threadId, out var history))
            throw new InvalidOperationException("Unknown threadId. Start with AnalyzeAsync.");

        if (!_threadImageDataUrl.TryGetValue(threadId, out var dataUrl))
            throw new InvalidOperationException("Original image is not available for this thread.");

        // Повторяем Step1 с пометкой
        var step1 = await CallOpenAi_Step1Vision(dataUrl, ct, userNote);
        if (step1 is null || step1.ingredients.Length == 0) return null;

        _threadStep1[threadId] = step1;
        _threadIngredients[threadId] = step1.ingredients;

        // Подсказки из БД (только для контекста)
        var matches = _matcher.MatchFoodsDetailed(step1.ingredients);
        var matched = _matcher.CollapseMatchedRows(matches);
        _threadFoods[threadId] = matched;

        var foodsJson = _matcher.BuildFoodsJsonForPrompt(matched);
        var unmatched = _matcher.BuildUnmatchedCommaList(matches);

        var targetWeight = step1.weight_g > 0 ? step1.weight_g : 100m;
        var gramsTargets = ComputeGramsFromShares(step1.ingredients, step1.shares_percent, targetWeight);

        var finalPrompt = BuildFinalPromptFromShares(
            dish: step1.dish,
            ingredients: step1.ingredients,
            sharesPercent: step1.shares_percent,
            gramsTargets: gramsTargets,
            targetWeight: targetWeight,
            foodsJson: foodsJson,
            unmatchedList: unmatched,
            userNote: userNote
        );

        history.Add(new { role = "user", content = "[re-step1] " + JsonSerializer.Serialize(step1) });
        history.Add(new { role = "user", content = finalPrompt });

        if (_debugLog)
        {
            Console.WriteLine($"[Clarify Final by AI] Prompt chars={finalPrompt.Length}");
            Console.WriteLine($"[Clarify Final by AI] Prompt head:\n{SafeHead(finalPrompt)}");
        }

        var finalAi = await CallOpenAi_Final(history, model: _reasoningModel, ct: ct);
        if (finalAi is null)
        {
            if (_debugLog) Console.WriteLine("[Clarify Final by AI] ❌ Model returned null.");
            return null;
        }

        history.Add(new { role = "assistant", content = JsonSerializer.Serialize(finalAi) });

        var final = new NutritionResult(
            dish: finalAi.dish ?? step1.dish,
            ingredients: step1.ingredients,
            proteins_g: Math.Round(finalAi.proteins_g, 1),
            fats_g: Math.Round(finalAi.fats_g, 1),
            carbs_g: Math.Round(finalAi.carbs_g, 1),
            calories_kcal: Math.Round(finalAi.calories_kcal, 0),
            weight_g: Math.Round(finalAi.weight_g > 0 ? finalAi.weight_g : targetWeight, 0),
            confidence: Math.Clamp(finalAi.confidence, 0m, 1m)
        );

        var finalJson = JsonSerializer.Serialize(finalAi, new JsonSerializerOptions { PropertyNamingPolicy = null });

        return new NutritionConversation(
            threadId,
            final,
            matched,
            step1,
            finalPrompt,
            finalJson
        );
    }

    // === Core ===

    private async Task<NutritionConversation?> AnalyzeCore(string dataUrl, string? userNote, CancellationToken ct)
    {
        var threadId = Guid.NewGuid();
        _threadImageDataUrl[threadId] = dataUrl;

        // STEP 1 — фото → dish + ingredients + shares% + weight_g + confidence
        var step1 = await CallOpenAi_Step1Vision(dataUrl, ct, userNote);
        if (step1 is null || step1.ingredients.Length == 0) return null;

        _threadStep1[threadId] = step1;
        _threadIngredients[threadId] = step1.ingredients;

        // Подсказки из БД (только для контекста)
        var matches = _matcher.MatchFoodsDetailed(step1.ingredients);
        var matchedRows = _matcher.CollapseMatchedRows(matches);
        _threadFoods[threadId] = matchedRows;

        var foodsJson = _matcher.BuildFoodsJsonForPrompt(matchedRows);
        var unmatched = _matcher.BuildUnmatchedCommaList(matches);

        var targetWeight = step1.weight_g > 0 ? step1.weight_g : 100m;
        var gramsTargets = ComputeGramsFromShares(step1.ingredients, step1.shares_percent, targetWeight);

        // STEP 2 — финал считает ИИ
        var finalPrompt = BuildFinalPromptFromShares(
            dish: step1.dish,
            ingredients: step1.ingredients,
            sharesPercent: step1.shares_percent,
            gramsTargets: gramsTargets,
            targetWeight: targetWeight,
            foodsJson: foodsJson,
            unmatchedList: unmatched,
            userNote: string.IsNullOrWhiteSpace(userNote) ? "Initial compute from composition shares" : userNote!
        );

        if (_debugLog)
        {
            Console.WriteLine($"[Final by AI] Prompt chars={finalPrompt.Length}, matched_rows={matchedRows.Length}");
            Console.WriteLine($"[Final by AI] Prompt head:\n{SafeHead(finalPrompt)}");
        }

        var msgs = new List<object>
        {
            new { role = "system", content = "You are a meticulous nutrition analyst. Use FOODS_JSON as hints only. Produce final macros yourself. Reply JSON only." },
            new { role = "assistant", content = JsonSerializer.Serialize(new {
                dish = step1.dish, ingredients = step1.ingredients, shares_percent = step1.shares_percent, weight_g = step1.weight_g, confidence = step1.confidence
            })},
            new { role = "user", content = finalPrompt }
        };

        var finalAi = await CallOpenAi_Final(msgs, model: _reasoningModel, ct: ct);
        if (finalAi is null)
        {
            if (_debugLog) Console.WriteLine("[Final by AI] ❌ Model returned null.");
            return null;
        }

        // История
        msgs.Add(new { role = "assistant", content = JsonSerializer.Serialize(finalAi) });
        _threads[threadId] = msgs;

        var final = new NutritionResult(
            dish: finalAi.dish ?? step1.dish,
            ingredients: step1.ingredients,
            proteins_g: Math.Round(finalAi.proteins_g, 1),
            fats_g: Math.Round(finalAi.fats_g, 1),
            carbs_g: Math.Round(finalAi.carbs_g, 1),
            calories_kcal: Math.Round(finalAi.calories_kcal, 0),
            weight_g: Math.Round(finalAi.weight_g > 0 ? finalAi.weight_g : targetWeight, 0),
            confidence: Math.Clamp(finalAi.confidence, 0m, 1m)
        );

        var finalJson = JsonSerializer.Serialize(finalAi, new JsonSerializerOptions { PropertyNamingPolicy = null });

        return new NutritionConversation(
            threadId,
            final,
            matchedRows,
            step1,
            finalPrompt,
            finalJson
        );
    }

    // ===== Шаг 1 (визуалка) =====
    private async Task<Step1Snapshot?> CallOpenAi_Step1Vision(string dataUrl, CancellationToken ct, string? userNote)
    {
        var note = string.IsNullOrWhiteSpace(userNote) ? "" : $"\nUser note for adjustment: {userNote}";
        var messages = new List<object>
        {
            new { role = "system", content =
                "You detect dish, English-only ingredients, and composition percentages from a photo. Reply JSON only." },
            new {
                role = "user",
                content = new object[]
                {
                    new { type = "text", text =
$@"From the photo, output:
• dish (string)
• ingredients (array of strings, English only; avoid redundant variants)
• shares_percent (array of numbers aligned with ingredients; sum ≈ 100% ±2%)
• weight_g (portion weight): estimate; round to 5 g
• confidence in [0,1]
Rules:
• If seasonings are visible (e.g., black pepper), keep them but typical shares are very small (≤2%).
• shares_percent and ingredients must be same length and aligned.
Return exactly this JSON:
{{""dish"":""..."",""ingredients"":[], ""shares_percent"":[], ""weight_g"":0, ""confidence"":0}}{note}" },
                    new { type = "image_url", image_url = new { url = dataUrl } }
                }
            }
        };

        var request = new
        {
            model = _visionModel,
            messages = messages,
            response_format = new
            {
                type = "json_schema",
                json_schema = new
                {
                    name = "vision_step1",
                    schema = new
                    {
                        type = "object",
                        additionalProperties = false,
                        properties = new
                        {
                            dish = new { type = "string" },
                            ingredients = new { type = "array", items = new { type = "string" } },
                            shares_percent = new { type = "array", items = new { type = "number" } },
                            weight_g = new { type = "number", minimum = 0 },
                            confidence = new { type = "number", minimum = 0, maximum = 1 }
                        },
                        required = new[] { "dish", "ingredients", "shares_percent", "weight_g", "confidence" }
                    }
                }
            },
            temperature = 0.2
        };

        using var msg = new HttpRequestMessage(HttpMethod.Post, "https://api.openai.com/v1/chat/completions");
        msg.Headers.Authorization = new AuthenticationHeaderValue("Bearer", _apiKey);
        msg.Content = new StringContent(JsonSerializer.Serialize(request), Encoding.UTF8, "application/json");

        using var resp = await _http.SendAsync(msg, ct);
        if (!resp.IsSuccessStatusCode)
        {
            var err = await resp.Content.ReadAsStringAsync(ct);
            throw new InvalidOperationException($"OpenAI (vision step) error {(int)resp.StatusCode}: {err}");
        }

        using var stream = await resp.Content.ReadAsStreamAsync(ct);
        using var doc = await JsonDocument.ParseAsync(stream, cancellationToken: ct);
        var content = doc.RootElement.GetProperty("choices")[0].GetProperty("message").GetProperty("content").GetString();
        if (string.IsNullOrWhiteSpace(content)) return null;

        var step = JsonSerializer.Deserialize<Step1Snapshot>(content!,
            new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

        // Нормализация: длины + сумма = 100.0
        if (step is not null)
        {
            var ingredients = step.ingredients ?? Array.Empty<string>();
            var shares = step.shares_percent ?? Array.Empty<decimal>();

            if (shares.Length != ingredients.Length)
            {
                var fixedShares = new decimal[ingredients.Length];
                var n = Math.Min(fixedShares.Length, shares.Length);
                Array.Copy(shares, fixedShares, n);
                shares = fixedShares;
            }

            var sum = shares.Sum();
            if (sum > 0)
            {
                var k = 100m / sum;
                var fixedArr = shares.Select(v => Math.Round(v * k, 1)).ToArray();
                var diff = 100m - fixedArr.Sum();
                if (fixedArr.Length > 0)
                    fixedArr[^1] = Math.Round(fixedArr[^1] + diff, 1);
                shares = fixedArr;
            }

            step = step with { shares_percent = shares };
        }

        return step;
    }


    public async Task<NutritionConversation?> ClarifyFromStep1Async(
    Step1Snapshot step1,
    string userNote,
    CancellationToken ct)
    {
        // матчим подсказки из БД (для FOODS_JSON — только как hint)
        var matches = _matcher.MatchFoodsDetailed(step1.ingredients);
        var matched = _matcher.CollapseMatchedRows(matches);
        var foodsJson = _matcher.BuildFoodsJsonForPrompt(matched);
        var unmatched = _matcher.BuildUnmatchedCommaList(matches);

        var targetWeight = step1.weight_g > 0 ? step1.weight_g : 100m;
        var gramsTargets = ComputeGramsFromShares(step1.ingredients, step1.shares_percent, targetWeight);

        var finalPrompt = BuildFinalPromptFromShares(
            dish: step1.dish,
            ingredients: step1.ingredients,
            sharesPercent: step1.shares_percent,
            gramsTargets: gramsTargets,
            targetWeight: targetWeight,
            foodsJson: foodsJson,
            unmatchedList: unmatched,
            userNote: userNote
        );

        var msgs = new List<object>
    {
        new { role = "system", content = "You are a meticulous nutrition analyst. Use FOODS_JSON as hints only. Produce final macros yourself. Reply JSON only." },
        new { role = "assistant", content = JsonSerializer.Serialize(new {
            dish = step1.dish, ingredients = step1.ingredients, shares_percent = step1.shares_percent, weight_g = step1.weight_g, confidence = step1.confidence
        })},
        new { role = "user", content = finalPrompt }
    };

        var finalAi = await CallOpenAi_Final(msgs, model: _reasoningModel, ct: ct);
        if (finalAi is null) return null;

        var final = new NutritionResult(
            dish: finalAi.dish ?? step1.dish,
            ingredients: step1.ingredients,
            proteins_g: Math.Round(finalAi.proteins_g, 1),
            fats_g: Math.Round(finalAi.fats_g, 1),
            carbs_g: Math.Round(finalAi.carbs_g, 1),
            calories_kcal: Math.Round(finalAi.calories_kcal, 0),
            weight_g: Math.Round(finalAi.weight_g > 0 ? finalAi.weight_g : targetWeight, 0),
            confidence: Math.Clamp(finalAi.confidence, 0m, 1m)
        );

        var finalJson = JsonSerializer.Serialize(finalAi, new JsonSerializerOptions { PropertyNamingPolicy = null });

        return new NutritionConversation(
            ThreadId: Guid.NewGuid(),
            Result: final,
            MatchedFoods: matched,
            Step1: step1,
            ReasoningPrompt: finalPrompt,
            CalcPlanJson: finalJson
        );
    }

    // ===== Финальный reasoning-промпт (ИИ считает итоговые БЖУ/ккал) =====
    private static string BuildFinalPromptFromShares(
        string dish,
        string[] ingredients,
        decimal[] sharesPercent,
        Dictionary<string, decimal> gramsTargets,
        decimal targetWeight,
        string foodsJson,
        string unmatchedList,
        string userNote)
    {
        var sbTarget = new StringBuilder();
        for (int i = 0; i < ingredients.Length; i++)
        {
            var name = ingredients[i];
            var share = i < sharesPercent.Length ? sharesPercent[i] : 0m;
            gramsTargets.TryGetValue(name, out var g);
            sbTarget.AppendLine($"- {name}: {share}%  → target {g} g");
        }

        return $@"
Clarification: {userNote}

Dish: {dish}

You will compute FINAL nutrition for the whole serving.
Use FOODS_JSON as hints only. If a food isn't present there, use reasonable analogs/knowledge.
Hard rules:
• Keep items aligned with the given INGREDIENTS (same order, do not drop items).
• Keep grams per item close to targets; total ≈ TARGET_WEIGHT_G (±10%).
• Seasoning caps: black pepper 0.3–2 g; salt 1–3 g; dried spices 0.5–3 g; fresh herbs 3–8 g.
• Plausible per-100g ranges (guideline, not output): P≤80 g, F≤100 g, C≤95 g.
• Energy consistency: calories_kcal must equal 4*proteins_g + 9*fats_g + 4*carbs_g within ±3%.
• Output JSON ONLY using the schema below.

INGREDIENTS & TARGET GRAMS:
{sbTarget}

FOODS_JSON (hints; per-100g & kcal_per_g for matched items):
{foodsJson}

UNMATCHED: {(string.IsNullOrWhiteSpace(unmatchedList) ? "(none)" : unmatchedList)}

TARGET_WEIGHT_G: {targetWeight}

Return ONLY:
{{
  ""final"": {{
    ""dish"": ""string"",
    ""weight_g"": number,
    ""proteins_g"": number,
    ""fats_g"": number,
    ""carbs_g"": number,
    ""calories_kcal"": number,
    ""confidence"": number,
    ""per_ingredient"": [
      {{
        ""name"": ""string"",
        ""grams"": number,
        ""per100g_proteins_g"": number,
        ""per100g_fats_g"": number,
        ""per100g_carbs_g"": number,
        ""kcal_per_g"": number
      }}
    ]
  }}
}}";
    }

    // ===== Вызов OpenAI: вернуть финальный JSON =====
    private async Task<FinalPayload?> CallOpenAi_Final(
        IEnumerable<object> messagesHistoryWithUserPrompt,
        string model,
        CancellationToken ct)
    {
        var responseFormat = new
        {
            type = "json_schema",
            json_schema = new
            {
                name = "final_nutrition",
                schema = new
                {
                    type = "object",
                    additionalProperties = false,
                    properties = new
                    {
                        final = new
                        {
                            type = "object",
                            additionalProperties = false,
                            properties = new
                            {
                                dish = new { type = "string" },
                                weight_g = new { type = "number", minimum = 0 },
                                proteins_g = new { type = "number", minimum = 0 },
                                fats_g = new { type = "number", minimum = 0 },
                                carbs_g = new { type = "number", minimum = 0 },
                                calories_kcal = new { type = "number", minimum = 0 },
                                confidence = new { type = "number", minimum = 0, maximum = 1 },
                                per_ingredient = new
                                {
                                    type = "array",
                                    minItems = 1,
                                    items = new
                                    {
                                        type = "object",
                                        additionalProperties = false,
                                        properties = new
                                        {
                                            name = new { type = "string" },
                                            grams = new { type = "number", minimum = 0 },
                                            per100g_proteins_g = new { type = "number", minimum = 0 },
                                            per100g_fats_g = new { type = "number", minimum = 0 },
                                            per100g_carbs_g = new { type = "number", minimum = 0 },
                                            kcal_per_g = new { type = "number", minimum = 0 }
                                        },
                                        required = new[] { "name", "grams", "per100g_proteins_g", "per100g_fats_g", "per100g_carbs_g", "kcal_per_g" }
                                    }
                                }
                            },
                            required = new[] { "dish", "weight_g", "proteins_g", "fats_g", "carbs_g", "calories_kcal", "confidence", "per_ingredient" }
                        }
                    },
                    required = new[] { "final" }
                }
            }
        };

        var request = new
        {
            model = model, // напр. "o4-mini"
            messages = messagesHistoryWithUserPrompt,
            response_format = responseFormat
            
        };

        using var msg = new HttpRequestMessage(HttpMethod.Post, "https://api.openai.com/v1/chat/completions");
        msg.Headers.Authorization = new AuthenticationHeaderValue("Bearer", _apiKey);
        msg.Content = new StringContent(JsonSerializer.Serialize(request), Encoding.UTF8, "application/json");

        if (_debugLog)
        {
            var bodyHead = await msg.Content.ReadAsStringAsync(ct);
            Console.WriteLine($"[OpenAI req] body head: {SafeHead(bodyHead)}");
        }

        using var resp = await _http.SendAsync(msg, ct);
        var respText = await resp.Content.ReadAsStringAsync(ct);

        if (!resp.IsSuccessStatusCode)
        {
            Console.WriteLine($"[OpenAI resp] HTTP {(int)resp.StatusCode}: {SafeHead(respText)}");
            throw new InvalidOperationException($"OpenAI final error {(int)resp.StatusCode}: {respText}");
        }

        if (_debugLog) Console.WriteLine($"[OpenAI resp] head: {SafeHead(respText)}");

        using var doc = JsonDocument.Parse(respText);
        var content = doc.RootElement.GetProperty("choices")[0].GetProperty("message").GetProperty("content").GetString();
        if (string.IsNullOrWhiteSpace(content)) return null;

        var outer = JsonSerializer.Deserialize<FinalOuter>(content!,
            new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
        return outer?.final;
    }

    // ===== Утилиты/DTO =====

    private static Dictionary<string, decimal> ComputeGramsFromShares(string[] ingredients, decimal[] sharesPercent, decimal weight)
    {
        var dict = new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase);
        for (int i = 0; i < ingredients.Length; i++)
        {
            var share = (i < sharesPercent.Length) ? sharesPercent[i] : 0m;
            var g = Math.Round(weight * share / 100m, 1);
            dict[ingredients[i]] = g;
        }
        return dict;
    }

    private static string SafeHead(string s)
    {
        var max = Math.Min(800, s.Length);
        return s.Substring(0, max).Replace("\n", "\\n");
    }

    // ===== DTO финального ответа от модели =====
    private sealed class FinalOuter { public FinalPayload? final { get; set; } }
    private sealed class FinalPayload
    {
        public string? dish { get; set; }
        public decimal weight_g { get; set; }
        public decimal proteins_g { get; set; }
        public decimal fats_g { get; set; }
        public decimal carbs_g { get; set; }
        public decimal calories_kcal { get; set; }
        public decimal confidence { get; set; }
        public PerIng[] per_ingredient { get; set; } = Array.Empty<PerIng>();
    }
    private sealed class PerIng
    {
        public string name { get; set; } = "";
        public decimal grams { get; set; }
        public decimal per100g_proteins_g { get; set; }
        public decimal per100g_fats_g { get; set; }
        public decimal per100g_carbs_g { get; set; }
        public decimal kcal_per_g { get; set; }
    }
}
