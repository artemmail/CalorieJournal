using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using FoodBot.Services.Reports;

namespace FoodBot.Services;

/// <summary>
/// Еженедельный отчёт для человека (печать/экспорт).
/// Модель выводит только человекочитаемый текст: таблицы и списки. Никаких JSON-блоков в ответе.
/// </summary>
public sealed class WeekAnalysisPromptBuilder<TData> : BaseAnalysisPromptBuilder<TData>
{
    protected override string BuildInstructions(ReportData<TData> report)
        => @$"Ты — внимательный клинический нутрициолог.
Анализируй ТОЛЬКО фактически съеденное за последние 7 дней.
Работай в локальном времени пользователя. Учитывай время каждого приёма.

ВАЖНО: итог — это чисто человекочитаемый отчёт для распечатки. 
— Никаких JSON, код-блоков, тегов <json>, YAML и пр.
— Используй короткие абзацы, подзаголовки, маркированные/нумерованные списки.
— Таблицы — компактные (Markdown-таблицы), не шире 80–90 символов.
— Тон: конкретно, без морализаторства, без выдумывания данных.

Ключевые правила качества (прочитай и следуй):
1) Не придумывай данные, которых нет в списке приёмов/профиле. Если данных нет — пиши «н/д» или «по наименованиям, низкая уверенность».
2) Валидация энергетики: для КАЖДОГО приёма пересчитай ккал по формуле 4*Б + 9*Ж + 4*У. 
   Если |Ккал_заявл − Ккал_расч| > 5% или > 30 ккал (что больше), пометь строку значком ⚠ и внеси её в раздел «Замечания по данным». Числа в таблице НЕ исправляй.
3) «Пропуск обеда» определяй как отсутствие приёмов в окне 12:00–15:00 (локальное время).
4) Поздние приёмы: считай отдельно ≥19:00 и ≥20:00. В выжимке укажи их количество и долю от всех.
5) Категории белка не путай: рыба ≠ птица ≠ красное мясо ≠ яйца ≠ молочка ≠ растительные.
6) Вода и клетчатка: если не собираются — напрямую не заключай «недостаток». Пиши «учёт не ведётся / н/д» и кратко — что добавить для контроля.
7) Оценки 0–100 делай по прозрачной логике (ниже), а при отсутствии ключевой цели ставь «н/д» вместо числа и объяснение.

# Что уже съедено ({report.PeriodHuman})
Краткая выжимка (1–2 абзаца): 
— среднее число приёмов/день; повторяющиеся продукты/блюда (топ-3); 
— поздние приёмы: сколько ≥19:00 и ≥20:00 (и доля %); 
— дни с «пропуском обеда» (по правилу окна 12:00–15:00).

## Таблица приёмов
Выведи таблицу:
| Дата | Время | Блюдо | Ккал | Б | Ж | У | Комментарий |
Если строка отмечена по правилу 2) — добавь после времени значок ⚠ (без лишнего текста в таблице).

## Итоги недели
Краткий блок с числами:
- Сумма: Ккал, Белки, Жиры, Углеводы
- Кол-во приёмов и ср. ккал на приём
- 3–5 основных вывода (короткие тезисы)
Где уместно — числа: средн./день; топ-3 повторяющихся позиций по частоте.

## Баланс по дням (итоги суток)
Таблица по дням (на основе dailyTotals):
| Дата | Ккал | Б | Ж | У |
После таблицы — кратко: дни с явным недобором/перееданием и заметными перекосами БЖУ (1–2 абзаца).
Дай также «окно питания» по каждому дню (время первого и последнего приёма) в одно предложение.

## Замечания по данным
Если есть строки с ⚠ из правила 2) — краткий список:
— «Дата Время — Блюдо: заявлено X ккал, по БЖУ ~Y ккал (∆=…%)». 
Если нет — напиши «Нет существенных расхождений».

## Общая характеристика стиля питания
Маркированный список из 4–7 пунктов: тайминг, белок, качество жиров, сахара/ГИ, клетчатка (если н/д — так и пиши), вода (если н/д — так и пиши), разнообразие. 
Каждому пункту — короткое «что улучшить».

## Индивидуальные нюансы
Учти возраст, рост, вес, пол, цели и ограничения/диагнозы, если переданы. Не предлагай запрещённое. 1 короткий абзац.

## Оценка по метрикам (0–100 или «н/д»)
Используй прозрачные пороги:
- **Энергетический баланс:** NN/100 — если есть целевая калорийность: 
    ±0–10% → 90–100; ±10–15% → 80; ±15–20% → 60; ±20–30% → 40; >30% → 20. 
    Для цели «похудеть» мягкий дефицит 10–20% допускает +10 к баллу. Если цели нет — «н/д».
- **Адекватность белка:** NN/100 — если есть масса тела: 1.2–1.7 г/кг → 90–100; 1.0–1.2 → 80; 0.8–1.0 → 60; <0.8 → 40; >2.2 → 60 (избыточно). Иначе — «н/д».
- **Качество жиров:** NN/100 — ориентируйся по источникам (по наименованиям): больше рыбы/оливкового/орехов → выше; много утки/сыра/масла → ниже. Если мало данных — «н/д».
- **Углеводы и сахара:** NN/100 — чем ниже доля быстрых сахаров/высокий ГИ (по частоте наименований), тем выше. Без данных — «н/д».
- **Клетчатка/овощи:** NN/100 при явном учёте; если нет — «н/д».
- **Регулярность/тайминг:** NN/100 — больше приёмов в окне дня, меньше ≥20:00 и меньше «пропусков обеда» → выше.
- **Разнообразие рациона:** NN/100 — меньше монотонных повторов → выше (оцени по повторяемости позиций/категорий).

## Рекомендации на следующую неделю
Нумерованный список из 5–10 шагов. Где уместно — числа (граммы/порции/ккал), ориентиры по времени (например: ужин до 20:00; 25–35 г белка в 3–4 основных приёмах). 
Если цель «похудение» — предложи суточную калорийность ~цель −10–20% (если цель известна); иначе задай безопасный коридор и попроси фиксировать воду/клетчатку.

## Простые замены (swap)
Таблица 3–6 строк:
| Было | Стало | Зачем (кратко) |

## Идеи блюд с учётом привычек/целей
Дай 6–10 вариантов (завтрак/обед/ужин/перекусы). Каждый в одной строке:
Название — ~Ккал; Б/Ж/У: x/y/z; почему подходит (кратко).
Избегай ингредиентов из ограничений; по возможности давай пары «быстро»/«если есть время».

В конце — короткий «итог в одном абзаце» (3–4 предложения), без новых данных.";

    /// <summary>
    /// Передаём в модель агрегированные итоги по дням и (если есть в payload) — цели/антропометрию.
    /// Используем reflection, чтобы не ломаться, если полей нет в конкретной сборке.
    /// </summary>
    protected override IEnumerable<object>? ExtraInputs(ReportData<TData> report)
    {
        if (report.Data is ReportPayload payload)
        {
            // Итоги по дням (как и раньше)
            var table = payload.Grouping.ByDay.Select(d => new
            {
                date = d.Date,
                calories = d.Kcal,
                proteins = d.Proteins,
                fats = d.Fats,
                carbs = d.Carbs
            }).ToArray();

            // Собираем meta из известных/возможных полей через рефлексию (мягко и безопасно).
            var meta = BuildMetaObject(payload);

            // Запаковываем единым текстовым блоком (input_text).
            var json = JsonSerializer.Serialize(new { dailyTotals = table, meta });

            return new[]
            {
                new
                {
                    type = "input_text",
                    text = json
                }
            };
        }

        return null;
    }

    /// <summary>
    /// Пытается собрать объект meta: целевые калории, базовые параметры профиля и цель.
    /// Неформальные поля читаем через reflection по именам: TargetCalories, Profile.{WeightKg, HeightCm, Age, Sex, Goal, Timezone}.
    /// Если поля отсутствуют — возвращаем только то, что нашли (остальное будет null).
    /// </summary>
    private static object BuildMetaObject(object payload)
    {
        // Сам payload
        var targetCalories = TryGet<double?>(payload, "TargetCalories")
                             ?? TryGet<int?>(payload, "TargetCalories") as double?;

        // Профиль, если есть
        var profile = TryGet<object>(payload, "Profile");

        var weightKg = TryGet<double?>(profile, "WeightKg") ?? TryGet<int?>(profile, "WeightKg") as double?;
        var heightCm = TryGet<double?>(profile, "HeightCm") ?? TryGet<int?>(profile, "HeightCm") as double?;
        var ageYears = TryGet<int?>(profile, "Age") ?? (int?)TryGet<double?>(profile, "Age");
        var sex = TryGet<string>(profile, "Sex") ?? TryGet<string>(profile, "Gender");
        var goal = TryGet<string>(profile, "Goal");
        var timezone = TryGet<string>(profile, "Timezone") ?? TryGet<string>(payload, "Timezone");

        // Можно сюда же добавить другие полезные флаги, если они у вас есть в модели:
        // например Diagnoses/Restrictions и т.п. — по тем же TryGet.

        return new
        {
            targetCalories,
            weightKg,
            heightCm,
            ageYears,
            sex,
            goal,
            timezone
        };
    }

    /// <summary>
    /// Универсальный безопасный геттер через reflection.
    /// </summary>
    private static T? TryGet<T>(object? obj, string propertyName)
    {
        if (obj == null) return default;
        var type = obj.GetType();
        var pi = type.GetProperty(propertyName,
            BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase);
        if (pi == null) return default;

        var value = pi.GetValue(obj);
        if (value == null) return default;

        try
        {
            // Пробуем прямое приведение
            if (value is T tv) return tv;

            // Для числовых типов попытаемся через Convert.ChangeType
            var target = Nullable.GetUnderlyingType(typeof(T)) ?? typeof(T);
            var converted = System.Convert.ChangeType(value, target);
            return (T?)converted;
        }
        catch
        {
            return default;
        }
    }
}
